# 反射

1. 什么是反射呢?   *反射就是在java中一个类被加载时 在堆中的一个对象,一个拥有关于这个类结构的对象*

![image-20220102184936109](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20220102184936109.png)

```java
package Reflection_;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Properties;

/**
 * 充分体现了万物皆可以对象的理念
 */
public class Test {
    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {
        Properties properties = new Properties();
        properties.load(new FileReader("src\\Cat.properties"));
        //拿到全类名
        String classPath = properties.getProperty("class");
        //拿到方法名
        String method = properties.getProperty("method");
        //拿到一个age成员变量名
        String age = properties.getProperty("age");


        //拿到和某个类(这里就是Cat)绑定的 class对象
        Class<?> catClass = Class.forName(classPath);
        //通过一个class的对象来创建一个cat对象
        Object cat = catClass.newInstance();
        Object dog = new Dog();

        //通过绑定的class对象来拿到绑定了Cat指定方法的method的对象
        Method method1 = catClass.getMethod(method);
        //用该对象来调用该类的方法
        method1.invoke(cat);

        //通过绑定的class对象来拿到对应类的成员字段
        Field field = catClass.getField("age");
        Object o = field.get(cat);
        System.out.println(o);

        //通过绑定的的class对象来拿到对应的构造器
        Constructor<?> constructor = catClass.getConstructor();
        //catClass.getConstructor()小括号里要来指定参数的构造器(没有就是无参构造器)
        System.out.println(constructor);

    }
}


```

# Class类的分析 

1. 在类加载的时期无论对象创建了多少次 对应的Class对象只会创建一次  (在多线程的情况下同样适用 那是因为**底层加了锁的**)
2. 反射的优点在于他可以动态的来创建和使用对象
3. 缺点也很明显 反射是纯解释执行对方法是有影响的

```java
package Reflection_;

import java.lang.reflect.Method;

public class Test02 {
    public static void main(String[] args) throws Exception {
        //演示执行速度的差异
        f1();
        f2();
    }

    public static void f1(){
        Cat cat = new Cat();
        long start = System.currentTimeMillis();
        for (int i = 0; i<999999999;i++){
            cat.hi();
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }

    public static void f2() throws Exception {
        Class<?> catClass = Class.forName("Reflection_.Cat");
        Object cat = catClass.newInstance();
        Method hi = catClass.getMethod("hi");
        long start = System.currentTimeMillis();
        for (int i = 0; i<999999999;i++) {
            hi.invoke(cat);
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }
}

```

* 当然你是可以一点优化的:那就是关闭安全访问检查 ----- 

* ```java
  public static void f3() throws Exception {
          Class<?> catClass = Class.forName("Reflection_.Cat");
  
          Object cat = catClass.newInstance();
          Method hi = catClass.getMethod("hi");
          hi.setAccessible(true);//这里就是关闭了检查 --- true 就是关闭检查 false 就是不关闭检查
          long start = System.currentTimeMillis();
          for (int i = 0; i<999999999;i++) {
              hi.invoke(cat);
          }
          long end = System.currentTimeMillis();
          System.out.println(end - start);
      }
  ```

## 获取类对象的途径

1. 获取类对象的途径一般有6种但实际上是只有4种 根据不同的阶段来实现的不同

* 在编码阶段就用 : Class 提供的静态方法 Class.forName() // 括号里面传入全类名
* 类加载阶段 : 对于已经加载的类 可以使用类名.class类获取 例如 : String.class
* 运行的阶段: 可以通过getClass()方法来获取
* 当然还可以通过获得类加载器 来加载类从而来获取类对象  注意哦 每个对象的类加载器是共有的 只是每个class对象都可以通过方法去拿到类加载器

```java
package Reflection_;

public class Test03 {
    public static void main(String[] args) throws ClassNotFoundException {
        //演示不同的类加载原理

        //1. 使用forName()  这种一般用于使用配置文件类读取
        Class<?> cls1 = Class.forName("Reflection_.Cat");

        //2. 通过xxx.class 这种一般用于参数的传递
        Class<Cat> cls2 = Cat.class;

        //3. 使用getClass()
        Cat cat = new Cat();
        Class<? extends Cat> cls3 = cat.getClass();

        //4.使用共用的类的类加载器
        ClassLoader classLoader = cat.getClass().getClassLoader();
        Class<?> cls5 = classLoader.loadClass("Reflection_.Dog");
        Class<?> cls4 = classLoader.loadClass("Reflection_.Cat");

        System.out.println(cls1.hashCode());
        System.out.println(cls2.hashCode());
        System.out.println(cls3.hashCode());
        System.out.println(cls4.hashCode());
        System.out.println(cls5.hashCode());


    }
}


```

```java
package Reflection_.Method02;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class Method01 {
    public static void main(String[] args) throws Exception {
        //演示一下class类的常用方法
        //得到class对象
        Class<?> Catclass = Class.forName("Reflection_.Method02.Cat");

        //演示方法
        //1. 返回名字
        String name = Catclass.getName();
        System.out.println(name);
        //2.获取这个类对象的全部接口
        Class<?>[] interfaces = Catclass.getInterfaces();
        for (Class<?> anInterface : interfaces) {
            System.out.println(anInterface);
        }

        //3. 得到该类的类加载器
        ClassLoader classLoader = Catclass.getClassLoader();

        //4. 得到他的父类
        Class<?> superclass = Catclass.getSuperclass();
        System.out.println(superclass);

        //5. 得到他全部的构造器
        Constructor<?>[] constructors = Catclass.getConstructors();
        for (Constructor<?> constructor : constructors) {
            System.out.println(constructor);
        }

        //6.得到他的全部属性
        Field[] declaredFields = Catclass.getDeclaredFields();
        for (Field declaredField : declaredFields) {
            System.out.println(declaredField);
        }

        //7. 得到他的方法
        Method method = Catclass.getMethod("hi");
        method.invoke(Catclass.newInstance());
        
        //8.看看是不是共有的类加载器
        Class<Dog> dogClass = Dog.class;
        Class<Cat> catClass = Cat.class;
        System.out.println(dogClass.getClassLoader() == catClass.getClassLoader());


    }
}


interface IA extends IB {
}

interface IB {
}

class Animal {
}


class Cat extends Animal implements IA {
    public String name = "lucy";
    public int age = 10;

    public Cat() {
    }

    public Cat(String str) {
    }

    public Cat(int i) {
    }

    public void hi() {
        System.out.println("喵喵叫");
    }
}

```



* 当然还有两种比较特殊的 就是基本数据类型的 直接用 .class 就可以了 比如 : int.class
* 还有就是另一种 基本数据类型的包装类 例如: Integer.TYPE

## 那些类具有class类呢

1. 全部的类
2. 接口
3. 枚举
4. 数组
5. void
6. Class自己 (它属于全部类的部分)
7. 注解
8. 基本数据类型

## 在类加载的阶段里

* 类加载分为静态加载 和 动态加载
* 静态加载就是:在编译的时候就要检查类的相关信息是否合理 是否正确
* 动态加载就是在需要这个类的时候才加载 在编译的时候不会检查这个类是否合理 是否正确

![image-20220102192705416](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20220102192705416.png)

## 通过class对象来创建对象实例

* 有一个过时的方法:就是class对象的newInstance()
* 还有就是通过构造的newInstance()的方法来创建对象实例()括号里放进指定的实参

```java 
package Reflection_.Methods;

import java.lang.reflect.Constructor;

public class ReTest {
    public static void main(String[] args) throws Exception {
        Class<Person> personClass = Person.class;
        //1.通过class对象的newInstance
        Person person = personClass.newInstance();
        //2. 通过构造器

        //2.1 无参构造器
        Constructor<Person> constructor = personClass.getConstructor();
        Person person1 = constructor.newInstance();

        //2.2 指定的构造器
        Constructor<Person> constructor1 = personClass.getConstructor(int.class);
        Person person2 = constructor1.newInstance(100);

        //2.3 通过爆破(暴力破解) 来获取私有的构造器
        Constructor<Person> constructor2 =
                personClass.getDeclaredConstructor(int.class, String.class, double.class);

        constructor2.setAccessible(true);
        Person lucy = constructor2.newInstance(100, "lucy", 100.0);

        System.out.println(person);
        System.out.println(person1);
        System.out.println(person2);
        System.out.println(lucy);


    }
}

```

* 其他访问字段 方法 都是一样的
