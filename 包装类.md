# 包装类

***每个基本数据类型都有包装类***

1. 装箱就是 基本数据类型 ----- 包装类
2. 拆箱就是  包装类 ---- 基本数据类型

来看看如何手动装箱和拆箱

```java
public class BasicClass {
    public static void main(String[] args) {
        //装箱
        int n = 1;
        Integer num1 = Integer.valueOf(n);
        //拆箱
        n = num1.intValue();
        System.out.println(n+"的包装类"+num1);
    }
}
```

再来看看自动装箱和拆箱

```java
int n2 = 10;
        Integer num3 = n2;// 这里就调用的是 valueOf()
        n2 = num3; //这是是 intValue()
```

1. 一真大师 ture ? Integer(1): Double(2.0)
2. 对于一真大师  后面的求值 会自动转换为容量最大来计算
3. 来看看眼

```java
System.out.println(true ? new Integer(1) : new Double(2));
```

![image-20211114201638245](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211114201638245.png)

### 再来讲讲 包装类 和 String之间 的互相转换

```java
//包装类 和 String 类的自动装换
        //String ----- 包装类
        String str = "IOTU";
        Integer number1 = Integer.parseInt("1232"); //在Integer 中有个parseInt的方法可以来把字符串解析成数字
        Integer number2 = new Integer("111");//构造器也可以
        //包装类转化成 ----- String
        String str2 = String.valueOf(123);//这是String的转换值的操作
        String str3 = 123+"";//这个很巧妙
        String str4 = num4.toString();//这个用的是包装类里的toString 方法
```

### 来看看Integer 和  Character 的常用方法

```java
public class AlwaysMethod {
    public static void main(String[] args) {
        System.out.println(Integer.MAX_VALUE);
        System.out.println(Integer.MIN_VALUE);
        System.out.println(Character.isDigit('1'));
        System.out.println(Character.isLetter('A'));
        System.out.println(Character.toLowerCase('A'));
        System.out.println(Character.toUpperCase('q'));
    }
}
```

### String 类

String 的创建方法的不同

```java
String str = "IOTU";
String str2 = new String("IOTU");

//String 的底层源码
private final byte[] value;
//接下来画图来演示
```

![image-20211114211922039](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211114211922039.png)

### 接下来就是 String 的常用方法

1. equals() // 区分大小写 判断相等
2. equalsIgnoreCase() // 不区分大小写 判断相等
3. length() // 返回字符串的长度
4. indexOf() // 返回某字符首次出现的索引
5. lastIndexOf() // 最后一次出现的索引
6. lastIndexOf()  
7. substring()  //返回指定索引的字符串 (前闭后开)
8. trim  去掉前后空格
9. charAt()  //返回索引的字符
10. toUpperCase()
11. toLowerCase()
12. concat() // 拼接字符串
13. replace() //替换字符串中的字符
14. split() 分割字符串 对于某些特殊的要转义
15. compareTo() //这个我也不懂
16. toCharArray() //变成字符数组
17. format() 格式化信息

```java
public class AlwaysMethod {
    public static void main(String[] args) {
        /*
        *   1. concat() // 拼接字符串
            2. replace() //替换字符串中的字符
            3. split() 分割字符串 对于某些特殊的要转义
            4. compareTo() //这个我也不懂
            5. toCharArray() //变成字符数组
            6. format() 格式化信息*/
        String str = " ";
        System.out.println(str.concat("大家").concat("好").concat("我叫IOTU"));
        String str2 = "哈哈,你们是最厉害的";
        System.out.println(str2.replace("最厉害","最牛批"));
        char[] strs = str2.toCharArray();
        System.out.println("--------");
        for (int i = 0; i < strs.length; i++)
        {
            System.out.println(strs[i]);
        }
        String formatString = "大家好,我是%s,今年%d岁,欢迎你来到%s.我们都是一家人!!!";
        System.out.println(String.format(formatString,"小新",18,"IOTU"));
		String str5 = "窗前明月光,疑是地上霜,举头望明月,低头思故乡";
        String[] strs1 = str5.split(",");
        for (int i = 0; i < strs1.length; i++)
        {
            System.out.println(strs1[i]);
        }
    }
}

```

### String Buffer(是一个final类不能被继承)

1. String Buffer 在堆中维护的对象中的属性value 不是final的 所以他是变的字符串序列
2. 正是因为他是可变的字符串序列也因此每次修改值是不能修改对象的地址所以会比String的效率更高
3. StringBuffer的方法和String的大部分方法一致 所以这里讲讲他常用的方法

#### 先看看String 和 StringBuffer 的相互交换

1. String ----- StringBuffer

```java
public class StringBuffer01 {
    @SuppressWarnings({"all"})
    public static void main(String[] args) {
        //String -----> StringBuffer
        //方法一
        String str = "IOTU";
        StringBuffer sb = new StringBuffer(str);
        System.out.println(sb.getClass());
        System.out.println(sb);
        System.out.println("------");
        //方法二
        StringBuffer sb2 = new StringBuffer();
        sb2.append(str);
        System.out.println(sb2);


    }

}

```

* StringBuffer ------  String

```java

//来看看StringBuffer -----> String
        //方法一
        StringBuffer sb3 = new StringBuffer("IOtu");
        //使用toString方法
        System.out.println(sb.toString().getClass());
        System.out.println(sb3);
		//方法二
        //直接new一个对象
        String str4 = new String(sb3);
        System.out.println(str4.getClass());
        System.out.println(str4);

```



***下面来看看StringBuffer的方法***

```java
public class StringBuffer02 {
    public static void main(String[] args) {
        //增
        StringBuffer sb = new StringBuffer("IOTU,大家好");
        sb = sb.append("我们一起加油啊");
        //删
//        System.out.println(sb.delete(0,4));
        //改
        System.out.println(sb.replace(0,1,"YY"));
        //插
        System.out.println(sb.insert(0,"2021"));
        //输出看看看
        System.out.println(sb);
    }
}

```



值得注意是 StringBuffer的有参构造器是不能传进null的源码来分析一下

```java
public class StringBuffer03 {
    public static void main(String[] args) {
        String str = null;
        StringBuffer sb = new StringBuffer(str); //会有空指针异常
    }
}

```

![image-20211115191045751](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211115191045751.png)

![image-20211115191100066](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211115191100066.png)

* 根据源码分析: 有参构造器是调用了String的length 的方法
* 所以传参不能是空对象是空对象就会导致空指针异常

```java
public class StringBuffer03 {
    public static void main(String[] args) {
        String str = null;
        StringBuffer sb = new StringBuffer(str);
        //上面的不行,下面的可以哦
        StringBuffer sb2 = new StringBuffer();
        sb.append(str);
    }
}

```

![image-20211115191414785](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211115191414785.png)

![image-20211115191426833](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211115191426833.png)

是不是说的你心服口服

```java
public class StringBuffer03 {
    public static void main(String[] args) {
        String str = null;
        try {
            str = null;
            StringBuffer sb = new StringBuffer(str);
        } catch (NullPointerException e) {
            System.out.println(e.getMessage());
            System.out.println("你的参数是个空的,我在内部要调用String 的length方法呢");
        }
        //上面的不行,下面的可以哦
        StringBuffer sb2 = new StringBuffer();
        sb2.append(str);
        System.out.println(sb2.length() + " "+ sb2);
    }
}

```

## StringBuilder 类

这个类和StringBuffer 类嘛共用的同一个API

所以嘛方法是一样的 就不多想解释

和StringBuffer 的不同则是 他是线程不同步的是有一定风险的

但是他的效率很高

### 总结一下

StringBuffer and StringBuilder 是可变的字符序列

而String 是不可变的 所以如果你要经常修改这些字符串建议用StringBuffer and StringBuilder

下面来演示一下他的效率对比

```java
public class String_Time {
    public static void main(String[] args) {
        long startTime = 0L;
        long endTime = 0L;
        //先看看StringBuffer
        StringBuffer sb = new StringBuffer();
        startTime = System.currentTimeMillis();
        for (int i= 0; i < 200000; i++)
        {
            sb.append(i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("StringBuffer = "+ (endTime - startTime));

        //StringBuilder
        StringBuilder sd = new StringBuilder();
        startTime = System.currentTimeMillis();
        for (int i= 0; i < 200000; i++)
        {
            sd.append(i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("StringBuilder= "+ (endTime - startTime));


        //String
        String str = "";
        startTime = System.currentTimeMillis();
        for (int i = 0; i< 200000; i++)
        {
            str += i;
        }
        endTime = System.currentTimeMillis();
        System.out.println("String= "+ (endTime - startTime));


    }
}

```

![image-20211115193629721](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211115193629721.png)

* 怎么样以后要多次修改字符串 就最好不要用String

***但是有多个引用指向某个字符串的时候就应该用String了***

