# java 总结

## 面向对象基础

### 方法

* 方法分为很多种 有静态方法 普通方法 构造方法 大致而言方法是给外部的代码提供了一些可以调用内部代码的接口

  1. 先从普通方法说起 

  * 普通方法 可以看成一个对象的行为动作

  2. 构造方法是用来实例化对象 和 初始化一些字段和属性的
  3. 静态方法 是 隶属于类的  每一个相同类的实例都可以调用这个方法 而且就算没有实例也可以调用

* 这里注意: 在java中区分方法是利用方法签名的 何为方法签名呢 :  方法签名就是**方法名 + 形参列表** 方法签名并没有包括**返回值类型**

* 方法参数的传递 : 方法参数的传递 本质就是值的复制传递  但是呢 对于不同的类型有着不一样的结果  基本数据类型就是直接将数据的值复制 而 引用数据类型是将地址复制 也就是坐标复制,**数据并没有复制**

* 这里讲讲方法重载和方法的重写

      1. 方法的重载主要解决的问题的方法的逻辑大致一样只是形参的类型不一样 这时就可以考虑使用方法的重载
         2. 方法的重写是要有条件的 **那就是继承** 没有继承就谈不上重写 重写是子类根据不用来实现不同的逻辑
         3. 方法重载的条件比较轻松 就只要求方法签名一致(也就是**方法名** + **方法形参列表**)
         4. 方法重写的方法就有点麻烦了 不仅要求方法签名一致还要求方法返回值类型一致 而且抛出的异常不能多于父类 而且 作用域不能缩小

### 继承

继承的主要目的是提高代码的复用性 提高效率

换句话说就是 一些基本的方法和属性 可以生来就有 自己就只用专心的来搞自己独有的方法和扩展原来的方法(**更加具体可以参考面向对象编程的笔记**)





### 类的多态

因为继承 和 重写 的缘故 让多态成为了java的一大特色

* 在继承了父类的子类是  如果将更多功能的子类压缩成父类的类型 那么重写的方法会被覆盖 这个时候每个方法的具体实现逻辑取决于子类的实现逻辑 
* 就造成一个假象 父类的相同方法居然可以实现不同的逻辑 但是这里有一点要值得强调 编译器只看编译类型 并且 字段(属性)不存在重写(动态绑定机制) 所以用父类的类型引用子类时访问的属性是父类里面的



### 抽象类

抽象类 就是为了重写而生的

* 抽象类的抽象方法可以只有方法签名 不需要方法体,但是遗憾的是抽象类具有了这个牛逼的特性后就失去了实例化的能力
* 抽象类毕竟还是一个类 所以他还是可以有属性和普通方法的   
* 抽象类可以没有抽象的方法 但是有了抽象方法必须要是抽象类

### 接口

接口可以理解为更加抽象的抽象类 他直接可以没有属性(字段)

1. 他是接口所以他的方法天生就是抽象的就不需要关键词abstract
2. 但是实现了接口的方法就必须来实现他全部的方法 就很难受
3. 所以可以在接口里定义一个默认(default)的方法让一个需要用的类来重写这个方法



### 包

就是便于管理我们写的java源文件 使得可以有同名的类名可以调用

JVM 怎么寻找类呢

1.  首先是在当前的包看有没有该类
2. 然后是在import看有没有该类
3. 最后看java.lang下有没有该类
4. 都没没就只能报错了



### 作用域

这里单独在讲讲作用域

作用域的那几个关键词是以包作用域为基础扩大或缩小范围的

**public** ------- 就是以包为作用域扩大至全部的外部代码都能用这个类

**private**------ 以包为作用域缩小至只有本类可以访问

**protected**------ 以包为作用域扩大至 只要是我的子类都可以访问

**friendly** -------- 这个就是默认  就是包作用域 在同一个包下随便访问



### final

单独来讲讲final 

1. 被他修饰的类不能被继承
2. 被他修饰的属性不能被修改
3. 被他修饰的方法不能被重写



### jar格式

jar的全名是java Archive:存档

jar的本质其实是一个压缩包zip 只是在jar中多了一些配置信息 这些配置信息是让jar能在JVM上运行的关键 暂时还不是很懂



### 模板

模板是对jar格式的一种进一步优化 因为在实际的运用中并不需要完整的java类库 

但是jar会把全部都打包 显得有些臃肿  从而模板开始出来 将jar文件分成多个jmod文件 然后需要那些就是组合那些

jmod中描述了各个模块的依赖关系 所以既精简了题集 还可以限制对外开放的类提高了代码的封装性









