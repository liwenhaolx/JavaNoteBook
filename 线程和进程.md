# 线程 和 进程

1. 什么是进程?

* 我们还是见得的理解一下 进程就好比一辆火车 线程就是他的车厢
* 所以线程是要共享资源的

2. 什么是程序呢

* 程序就是保存在此磁盘里的可执行文件是静态的 是一段指令的集合

## java中实现线程 和 进程的方法

1. 实现进程就是我们经常在用了run 一下
2. <img src="C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211203195923696.png" alt="image-20211203195923696" style="zoom:50%;" />

这样就开启了一个进程 

3. 开启线程的方法

* 要么继承一个Thread 的类
* 要么实现一个接口Runnable

```java
package Thread;

public class Processes {

    public static void main(String[] args) throws Exception {
        Dog dog = new Dog("jack", "red", 23);
        dog.start();
        int i = 0;
        while(true){
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + " " + (i++));
            if (i > 100){
                break;
            }
        }


    }
}

class Dog extends Thread{
    int age;
    String name;
    String color;

    public Dog(String name,String color,int age){
        this.name = name;
        this.color = color;
        this.age = age;
    }

    @Override
    public void run() {
        Thread.currentThread().setName("Dog");
        int i = 0;
        while(true){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("你好,java"+ (i++) +" " + Thread.currentThread().getName());
            if (i >= 50){
                break;
            }

        }
    }
}

```

<img src="C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211203201513210.png" alt="image-20211203201513210" style="zoom:40%;" />

* Runnable 的实现方式是一个代理的模式
* 就是将实现了Runnable的类 交给Thread 的对象来代理

```java
package Thread;
@SuppressWarnings({"all"})
public class Runnable_ {
    public static void main(String[] args) {
        Thread thread = new Thread(new Cat(10, "tom", "blue"));  //这里就是代理了让Thread来启动线程
        thread.start();
    }
}


class Cat implements Runnable{
    int age;
    String name;
    String color;

    public Cat(int age, String name, String color) {
        this.age = age;
        this.name = name;
        this.color = color;
    }

    @Override
    public void run() {
        int i = 0;
        while(i != 10){
            System.out.println("喵喵~~~ " + Thread.currentThread().getName());

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            i++;

        }
    }
}

```

* 两者本质上是没有什么区别的但是如果要共享资源的话用Runnable 更加的合适一点
* 下面来模拟一个售票系统(这个售票系统是没有bug的如果你把synchronized 去掉你就会超卖)

```java
package Thread;

public class Sell {
    public static void main(String[] args) {

        Ticket ticket = new Ticket();
        Thread thread = new Thread(ticket);
        Thread thread1 = new Thread(ticket);
        Thread thread2 = new Thread(ticket);
        thread.start();
        thread1.start();
        thread2.start();

    }
}
class Ticket implements Runnable{
    int num  = 100;

    @Override
    public void run() {

                while (true) {
                    synchronized (this) {
                        if (num <= 0) {
                            break;
                        }
                        System.out.println(Thread.currentThread().getName() + "售票员" + "买了一张票");
                        System.out.println("现在还剩" + (--num));
                    }

                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

//                        System.out.println("现在还剩" + (--num));


                }
            }

}
```

## 终止线程的方法

1. 让他自己终止 就是执行完run 方法后就终止
2. 也可以用通知的方式来将他停止

```java
package Thread;

public class Sell {
    public static void main(String[] args) {

        Ticket ticket = new Ticket();
        Thread thread = new Thread(ticket);
        Thread thread1 = new Thread(ticket);
        Thread thread2 = new Thread(ticket);
        thread.start();
        thread1.start();
        thread2.start();

        for (int i = 0; i< 10; i++){
            if (i == 5){
                ticket.setStop(false);  //通知线程该结束了
            }
            System.out.println("我是main方法" + i);
        }

    }
}
class Ticket implements Runnable{
    int num  = 100;
    boolean isStop = true;

    public boolean isStop() {
        return isStop;
    }

    public void setStop(boolean stop) { //这里就是通知模式的一部分 可以修改一个变量 来迫使run方法结束
        isStop = stop;
    }

    @Override
    public void run() {

                while (isStop) {
                    synchronized (this) {
                        if (num <= 0) {
                            break;
                        }
                        System.out.println(Thread.currentThread().getName() + "售票员" + "买了一张票");
                        System.out.println("现在还剩" + (--num));
                    }

                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

//                        System.out.println("现在还剩" + (--num));


                }

        System.out.println(Thread.currentThread().getName() + " " + "我结束了");
            }

}
```





## 线程的常用方法

1. setName
2. getName
3. setPriority  //设置优先级的
4. getPriority //获取优先级的
5. sleep //休眠的
6. intrrupt //中断线程的(意思是中断正在睡觉的线程)
7. join  //线程插队  一定是插队的线程执行完了 然后让他插队的那个线程再执行
8. yield //教礼让 就是让一下他 但是不一定能成功 和cpu有关系 CPU说我的资源很多 不用礼让

```java
package Thread;
//插队方法的演示
public class JoinMethods {
    public static void main(String[] args) {
        Tiger haha = new Tiger(10, "haha");
        Thread thread = new Thread(haha);
        thread.start();
        int i = 1;
        while(true){
            System.out.println("main" + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            i++;
            if (i == 5){

                try {
                    thread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
            if (i >= 10){
                break;
            }
        }
    }
}


class Tiger implements Runnable{
    int age;
    String name;

    public Tiger(int age, String name) {
        this.age = age;
        this.name = name;
    }

    @Override
    public void run() {
        int i = 0;
        while(true){
            System.out.println("我要吃肉 " + (++i));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (i >= 10){
                break;
            }
        }
    }
}

```

## 守护线程 和 用户线程

1. 用户线程 : 又叫工作线程  当线程的任务执行完后或通知方式结束 结束
2. 守护线程: 为了工作线程而服务的 当所有的用户线程结束时,守护线程自动结束 
3. 常见的守护线程 : 垃圾回收机制

```java
package Thread;

public class Daemon_ {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new m1());
        thread.setDaemon(true);
        thread.start();

        for (int i = 0; i < 10; i++){
            System.out.println("我是素食动物" + i);
            Thread.sleep(1000);
        }
    }
}

class m1 implements Runnable{
    @Override
    public void run() {
        while(true) {
            System.out.println("我要吃素");
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

## 线程的生命周期

1. 官方规定有6种状态

* new  //还没有启动的线程
* runnable // 在jvm中执行的状态
* blocked //堵塞的状态 一般是因为线程锁
* waiting //等待另一个线程完成指定的动作的线程
* timewaiting //正在等待另一个线程执行动作达到指定的时间的线程
* terminated  //线程退出的状态

![image-20211204085433284](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211204085433284.png)





## 线程同步

1. 线程同步就是对于一个内存的地址 在同一时刻只能有一个线程对他操作  当这个线程操作完成后,其他线程就可以操作了

* 利用synchronized  来进行互斥锁
* 谈谈他的具体步骤

1. 当一个线程拿到锁后,其他的线程就不能进入这个代码块 但拿到锁的线程执行完这个代码块的时候就把这个锁返回到原来的地方  这是其他的线程就可以来抢锁 抢到了就可以进入代码块来执行了
2. 也是这样所以就要求 这个锁必须是同一把  一般同步方法的锁是this 对象自己(非静态的)
3. 静态的方法那么就是类本身有个对象  (xxx.class)

## 死锁的情况

* 就是多个线程占用对方的锁资源 但是不肯相让谁也执行不了 就导致了死锁 一定要避免这种情况

```java
package Thread;

public class Thread_01 {
    public static void main(String[] args) {
        Test test = new Test(true);
        test.setName("线程A");

        Test test1 = new Test(false);
        test1.setName("线程B");

        test.start();
        test1.start();
    }
}

class Test extends Thread{
    static Object o1 = new Object();
    static Object o2 = new Object();
    boolean flag ;

    public Test(boolean flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        if (flag){
            synchronized (o1){
                System.out.println("我进入到一了 " + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o2){
                    System.out.println("我进入到二了 "+ Thread.currentThread().getName());
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }

        }else{
            synchronized (o2){
                System.out.println("我进入到三了 "+ Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                synchronized (o1){
                    System.out.println("我进入到四了 "+ Thread.currentThread().getName());
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }

        }
    }
}

```

## 释放锁

1. 什么情况下回释放锁呢

* 线程的同步方法和同步代码块执行完后就会释放锁
* 当前线程在同步方法或者同步代码块的时候遇到了break,return 就会释放锁
* 在执行同步代码块的时候出现了错误  或者是异常也会释放锁
* 当在同步方法中执行了线程的对象的wait方法也会线程暂停然后释放锁

2. 在下面的情况下不会释放锁

* **调用了sleep方法**
* ***在执行同步代码块的时候 其他线程调用了他的susend() 方法将线程挂起 也不是释放锁***

```java
package Thread;

import java.util.Scanner;

public class Homework01 {

    public static void main(String[] args) {
        Print print = new Print();
        Input input = new Input();

        print.start();
        input.start();
    }
}


class Print extends Thread{
    static boolean loop = true;

    @Override
    public void run() {
        int i = 1;
        while(loop){
            System.out.println("我在数数 " + i);
            i++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}


class Input extends Thread{

    @Override
    public void run() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Q表示结束");
        String next = scanner.next();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if ("Q".equals(next)){  //这里不用== 号是因为为了防止输入的字符串会被new成一个新的对象
            Print.loop = false;
        }
    }
}

```

```java
package Thread;

public class Homework02 {
    public static void main(String[] args) {
        Account account = new Account();
        Thread thread = new Thread(account);
        Thread thread1 = new Thread(account);
        thread.start();
        thread1.start();
    }
}


class Account implements Runnable{

    int balance = 10000;

    @Override
    public void run() {


            while(true) {

                synchronized(this) {
                    if (balance <= 0) {
                        System.out.println("余额不够了");
                        break;
                    }
                }

                System.out.println(Thread.currentThread().getName() + " 取走了1000");
                balance = balance - 1000;
                System.out.println("还剩 "+ balance);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }


        }

    }
}
```

