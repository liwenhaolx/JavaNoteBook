# 异常

1. 异常的事件分为两大类

* 1. 是错误(Error) : java 虚拟机 无法解决的错误
  2. Exception 异常 又分为编译异常 和 运行异常 
* 这里着重讲解 运行异常

运行异常 编译器是检查不出来的 通常是 程序的逻辑问题

常见的异常

1. NullPointerException 空指针异常
2. ArithmeticException 数学运算异常
3. ArrayIndexOutOfBoundsException  数组下标越界异常
4. ClassCastException 类型转换异常
5. NumberFormatException 数字格式不正确异常

先给大家看看类图

![image-20211114183303189](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211114183303189.png)

* 我在这里就着重的对运行异常中的这五个进行示例

1. ArithmeticException 数学运算异常

```java
int num1 = 10;
int num2 = 0;
int answer = num1 /num2;
```

![image-20211114183548952](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211114183548952.png)

2. NullPointerException 空指针异常

```java
public class NullPointException_ {
    public static void main(String[] args) {
        Person person = null;
        System.out.println(person.name);
    }
}


class Person{
    public String name;
}
```

![image-20211114183851873](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211114183851873.png)

3. ArrayIndexOutOfBoundsException  数组下标越界异常

```java
public class IndexOut_ {
    public static void main(String[] args) {
        int[] nums =new int[10];
        for (int i = 0; i <= nums.length; i++)
        {
            nums[i] = i;
        }
    }
}

```

![image-20211114184130206](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211114184130206.png)

4. ClassCastException 类型转换异常(还有在向下转型是没有父子关系强制转换可能会出现这类情况)

```java
public class ClassCast_ {
    public static void main(String[] args) {
        String name = "IOTU";
        int num = Integer.parseInt(name);
    }
}

```

![image-20211114184333353](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211114184333353.png)

```java
public class ClassCast_ {
    public static void main(String[] args) {
        String name = "IOTU";
        int num = Integer.parseInt(name);
        Person1 person1 = new Student();
    }
}
class Person1{
    String name;
}
class Student{
    String name;
}
```

![image-20211114185004620](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211114185004620.png)

5. NumberFormatException 数字格式不正确异常

```java
public class ClassCast_ {
    public static void main(String[] args) {
        String name = "IOTU";
        int num = Integer.parseInt(name);
    }
}

```

![image-20211114184514591](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211114184514591.png)



*** 对于编译异常 以后学习了数据库来学习***



## 异常的处理

方法之一是

try -- catch -- finally 

先介绍一下处理机制

```java
try{
    //可能抛异常的代码
    
}catch (Exception e){
    //将异常抛到这里
    //系统将异常封装成Exception对象e
    //得到的对象交给程序员自己处理
}finally{
    //无论catch 执不执行 都会执行这个代码
    //通常将释放资源的代码放到这里
}
```



在try代码块中只要出现异常就会 将异常抛给catch 然后就 执行catch 代码块的内容 无论怎么样都必须执行 finally 代码块的内容

1. 这里的可以有多个catch 代码块 也可以没有
2. 有多个catch代码块是 子类在前父类在后 (很好理解如果 父类在前 那不管是什么类型的异常都会抛给在前面的异常 那么后面的子类异常就不能用)

***这里演示多个catch代码块处理异常***

```java
public class ClassCast_ {
    public static void main(String[] args) {
        try {
            String name = "IOTU";
            int num = Integer.parseInt(name);

            Person1 person1 = new Person1();

            int num1 = 0;
            int num2 = 10;
            int answer = num2 / num1;
        } catch (NumberFormatException e) {
            System.out.println(e.getMessage());
        }catch (ClassCastException e1){
            System.out.println(e1.getMessage());
        }catch (ArithmeticException e2){
            System.out.println(e2.getMessage());
        }
        finally {
            System.out.println("请改正一下错误");
        }

    }
}
class Person1{
    String name;
}
class Student{
    String name;
}
```

***没有catch代码块***

```java
public class Exception2_ {
    public static void main(String[] args) {
        int num1 = 0;
        int num2 = 10;
        try {
            int res = num2 / num1;
        } finally {
            System.out.println("你的问题 我崩溃了");
        }
    }
}
```

![image-20211114190828986](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211114190828986.png)

### throws 异常处理

throws 处理异常就是自己不亲自解决 交给他的上级解决

运行时的异常默认是throws 

编译异常必须处理 没有默认处理的方式

还有注意的是子类重写的父类方法

子类要么抛出父类相同的异常 要么就 抛出 父类异常的子类

```java
public class ThrowException_ {
    public static void main(String[] args) {
        f1();
    }

    public static void f1(){

        try {
            f2();
        } catch (Exception e) {
            System.out.println("哈哈");
            System.out.println(e.getMessage());
        }

    }

    public static void f2() {
        int num = 0;
        int num2 = 12;
        double res = num2 / num;
    }
}

```

### 自定义一个异常

1. 自定义异常一般的是继承RunTimeException 的
2. 一般不继承Exception 因为Exception 是 编译异常  任何时候要显式的处理异常
3. 而RunTimeException 是 运行的异常 有默认的throws机制
4. 下面代码演示

```java
public class DiyException {
    public static void main(String[] args) {
        int age = 0;
        try {
            f1();
        } catch (Exception e) {
            System.out.println("你太厉害了吧");
        }finally{
            System.out.println("我们很抱歉 无法教你");
        }
    }
    public static void f1(){
        int age = 10;
        if (!(age >= 18 && age <= 65))
        {
            throw new AgeException("你的年龄太小了吧");
        }
    }
}

class AgeException extends RuntimeException{
    public AgeException(String message) {
        super(message);
    }
}

```

