# 集合总结

1. 先看看集合的框架图吧

<img src="C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211210155107111.png" alt="image-20211210155107111" style="zoom:50%;" />

<img src="C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211210155223440.png" alt="image-20211210155223440" style="zoom:50%;" />





2. 集合分为两类

* 一类是只存放值(Collection)
* 一类是存放键值对的(Map)

## Collection

* 在Collection 中有分为两类 一类是List 和 Set

### List

* 放在List里面的元素是有序可以重复的可以存放多个null

#### ArrayList

* ArrayList 的底层是维护的是一个数组

```java
//这里是演示添加的源码来看看具体的细节
public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    } //ArrayList的构造器 里面初始化了一个字段elementData  

//private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};  //这个字段是个空的Object的数组
```



* 具体的扩容细节就是

1. 如果调用的是无参构造器的话  默认是个空的上面的代码已经演示了
2. 在进行第一个添加的时候就是给一个默认的容量(10) 后面就是1.5倍扩容了

```java
//public boolean add(E e) {
        modCount++;
        add(e, elementData, size);  //这里是添加的方法
        return true;
    }
//这个是扩容的方法
private Object[] grow(int minCapacity) {
        int oldCapacity = elementData.length;
        if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            int newCapacity = ArraysSupport.newLength(oldCapacity,
                    minCapacity - oldCapacity, /* minimum growth */
                    oldCapacity >> 1           /* preferred growth */);////这里相当于是扩容1.5倍
            return elementData = Arrays.copyOf(elementData, newCapacity);  //newCapacity 这个的意思是现在最少需要多少的容量
        } else {
            return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];//第一次会执行这一步 返回一个Object的数组
            //DEFAULT_CAPACITY == 10 这个默认的容量是10
        }
    }


private Object[] grow() {
        return grow(size + 1);//这个size+1就赋给了minCapacity了
    }
```

* 如果第一次就是给一个指定容量的话那么以后就是按照这个指定容量来扩容1.5倍

#### Vector

* 他的底层其实也是一个Object数组 只是他是线程安全的因为他的方法上有(synchronized)修饰的可以实现线程的互斥
* 他的扩容的细节

```java
public Vector() {
        this(10);
    }

public Vector(int initialCapacity) {
        this(initialCapacity, 0);
    }

public Vector(int initialCapacity, int capacityIncrement) {
        super();
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        this.elementData = new Object[initialCapacity];//这里就是初始化了一个10个大小的数组
        this.capacityIncrement = capacityIncrement;
    }


int newLength = Math.max(minGrowth(1), prefGrowth(10-->就相当于是oldCapacity)) + oldLength;//这里就相当于是扩容两倍
int newCapacity = ArraysSupport.newLength(oldCapacity,
                minCapacity - oldCapacity,(1) /* minimum growth */
                capacityIncrement(0) > 0 ? capacityIncrement : oldCapacity//这里传入的是oldCapacity
                                           /* preferred growth */);
```

* 如果他是存入指定的容量就按照指定的容量的两倍扩容

#### LinkedList

1. 他的底层就不同于上面两个了他的底层维护了双向链表
2. 什么是链表呢这里就简单的介绍一下

<img src="C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211210185420174.png" alt="image-20211210185420174" style="zoom:50%;" />

* 上图就是一个双向的链表

因为是个双向链表所以他的删除和修改就特别的容易  但是对他而言查找就相对而言要难一点了

```java
public LinkedList() {
    }  // 调用无参的构造器 实例化了一个LinkedList的对象

public boolean add(E e) {
        linkLast(e);  //这里就是添加的方法
        return true;
    }

void linkLast(E e) {
        final Node<E> l = last; // 将last这个节点赋给l
        final Node<E> newNode = new Node<>(l, e, null);
        last = newNode;//在将现在这个新的节点赋给last
        if (l == null)//如果l等于空那么就把该节点赋给first
            first = newNode;
        else
            l.next = newNode;//不是的话就把该节点挂在他的后面
        size++;
        modCount++;
    }
```

* 上面的代码就基本的展示了添加的过程

#### List的总结

* 大致就是这样这就是大部分的常用的类以后要用其他类的时候看文档就是了
* 如果你的业务更加倾向于查找那么就用ArrayList或者Vector
* 如果你的业务更加倾向于增删那么就用LinkedList

* ps:注意这里没有总结他的常用方法 我认为方法要在实践中运用而不是能够靠总结就行的

### Set

* Set 和List的不同就是他是无序的不可重复的  不可有多个null

#### HashSet

* HashSet的底层是HashMap

* 而HashMap 的底层维护的是数组 + 链表 + 红黑树(红黑树不会深入的研究;至少现在不会)

```java
public HashSet() {
        map = new HashMap<>();  //调用HashSet的构造器结果实例化了一个HashMap对象  (初始化的时候是默认给了16个空间大小)
    }


public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted  这个是加载的因子
    }
//添加的逻辑以下是:
public boolean add(E e) {
        return map.put(e, PRESENT)==null;   //private static final Object PRESENT = new Object();  //相当于是个常量给定死了的
    }

public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }

Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];  //这里创建了一个newTab 
table = newTab;
return newTab;//这里又返回了一个newTab


Node<K,V> newNode(int hash, K key, V value, Node<K,V> next) {
        return new Node<>(hash, key, value, next);
    }
```

* 以上是没有重复的元素的添加方法
* 下面是添加重复代码的过程

```java
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }//这里是计算一个hash值


 else {
            Node<K,V> e; K k;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;  //这里就是去重的代码  首先你要满足hash值相同  然后在 是同一个对象 或者 他的的equals方法后相同  那么满足一个就可以
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;//到这里就说明是重复的的
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;  //这里就是把新的value 赋给了原来key对应value
                afterNodeAccess(e);
                return oldValue;
            }
        }
```

* HashSet 的扩容机制 

1. 调用无参构造器是就是默认一个16的容量大小的table表(就是Node 类型的数组(**HashMap$Node**))
2. 当table到了他的临界值就会扩容  扩容到原来的两倍
3. 在java8 里面就是如果有一条链表的长度到了8 然后table的容量>=64 就会树化  否则就是继续扩容.

```java
@SuppressWarnings({"all"})
public class HashSet_
{
    public static void main(String[] args) {
        HashSet hashSet = new HashSet();

       for (int i = 0; i<12; i++){
           hashSet.add(new Dog((String.valueOf(i))));
       }

       hashSet.add("java");
    }
}

class Dog{
    private String name;

    public Dog(String name) {
        this.name = name;
    }

    @Override
    public int hashCode() {
        return 100;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                '}';
    }
}
//可以跑跑这个代码验证一下
```

#### LinkedHashSet

* LinkedHashSet 是一个HashSet的子类

* 他的底层维护的是一个数组加双向的链表

<img src="C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211210194816469.png" alt="image-20211210194816469" style="zoom:50%;" />

* 大概就是这个样子的很简陋

* 因为这个特性就可以看起来他的的加入顺序和输出的顺序一样但是他的底层还是通过hash值来计算索引的并加入到相应的位置

* 既然是HashSet的子类那么他的扩容的机制就还是那一套了哦

#### TreeSet

1. 他的底层是TreeMap
2. TreeSet 就是可以比较 可以按照你的那一套规矩来排序 其他的嘛就不是特别重要所以这里就着重讲述一下这个比较原理会用到匿名内部类

```java
public TreeSet(Comparator<? super E> comparator) {
        this(new TreeMap<>(comparator));
    }


public boolean add(E e) {
        return m.put(e, PRESENT)==null;
    }

 public V put(K key, V value) {
        return put(key, value, true);
    }


private void addEntryToEmptyMap(K key, V value) {
        compare(key, key); // type (and possibly null) check
        root = new Entry<>(key, value, null);
        size = 1;
        modCount++;
    }

(TreeMap)
public V put(K key, V value) {
        return put(key, value, true);
    }

public boolean add(E e) {
        return m.put(e, PRESENT)==null;
    }
//核心的处理逻辑
private V put(K key, V value, boolean replaceOld) {
        Entry<K,V> t = root;
        if (t == null) {
            addEntryToEmptyMap(key, value);
            return null;
        }
        int cmp;
        Entry<K,V> parent;
        // split comparator and comparable paths
        Comparator<? super K> cpr = comparator;   //这里就是得到我们定义的比较器
        if (cpr != null) {
            do {
                parent = t;
                cmp = cpr.compare(key, t.key);  //调用了我们的比较方法
                if (cmp < 0)
                    t = t.left;//
                else if (cmp > 0)
                    t = t.right;
                else {
                    V oldValue = t.value;//如果cmp==0 的话
                    if (replaceOld || oldValue == null) {
                        t.value = value;//这里就是把值替换掉  因为这里呢是Set  value是个常量是个写死了的(PRESENT)
                    }
                    return oldValue;
                }
            } while (t != null);
```

```java
import java.util.*;
//测试的代码
@SuppressWarnings({"all"})
public class TreeSet_ {
    public static void main(String[] args) {
        TreeSet treeSet = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String)o1).length() - ((String)o2).length();
            }
        });

        treeSet.add("jack");
        treeSet.add("hello");
        treeSet.add("java");
        //因为treeSet的底层还是treeMap 而我们在treeSet中添加的是一个key 在treeMap的底层是遇到你规定的方式相同的key就是
        //把新的值赋给原来位置上的value

        System.out.println("treeSet=" + treeSet);
//


    }
}

```

Set 的方法和List的方法有些差异 但是基本的方法都差不多 用的时候查文档 在**实践中领会**



## Map

1. Map是一种键值对类型的集合
2. 可以用来存放任何引用数据类型 用于保存具有映射关系的键值对

3. key不允许重复但是value是可以允许重复的,这就说明了 key只能有一个null 但是value可以有多个null  满足映射的关系嘛 key就相当于x value 就相当于y

* **这里要强调一下的是在Map里面不仅有一个table表还有一个EntrySet(Set)  , KeySet(Set)  Values(Collection)  他们都只是方便我们遍历而已 里面存放的数据都只是table里的引用的,不要认为是一份新的数据 只是引用这就意味着 table 表变了 那么其他的都会跟着变**

#### HashMap



```java
static class Node<K,V> implements Map.Entry<K,V>  //所以在底层虽然table是个HashMap$Node 但是他可以存放Entry的原因了
```

<img src="C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211210202827972.png" alt="image-20211210202827972" style="zoom:50%;" />

* 这里就不追源码了因为这里的源码在HashSet 的时候已经追过了 因为HashSet的底层就是HashMap

* HashMap没有做互斥的工作 就是方法上没有关键字synchronized  所以他是线程不安全的

#### HashTable

* HashTable 是线程安全的

* ps: HashTable 的键值对都是不可以为null的

<img src="C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211210203500388.png" alt="image-20211210203500388" style="zoom:50%;" />

```java
public Hashtable() {
        this(11, 0.75f);
    }


table = new Entry<?,?>[initialCapacity];

 if (value == null) {
            throw new NullPointerException(); //这里保证了值不能为空
        }

int hash = key.hashCode(); //要调用hashCode的方法那么key也不能为空

//扩容的代码
int newCapacity = (oldCapacity << 1) + 1;  //左移1位相当于乘以2 在加1
```

#### Properties 

* 这个是HashTable的子类 他可以用来读取管理 一种配置文件
* 他的基本方法看文档这里就不多说什么

#### TreeMap

1. 你可以来指定排序的方式 这里就不在多说什么毕竟TreeSet 的底层就是你TreeMap(排序的方式是一key 为标准的)

#### LinkedHashMap

* 他是HashMap的子类  LinkedHashSet 的底层就是LinkedHashMap 这里也不多说什么了

## 工具类 ----  Collections

* 里面有许多的静态方法来操作Set and List and Map
* reverse 翻转
* sort 默认是自然排序 也可以你指定排序的方式 还是传入比较器 (匿名内部类的方式)
* swap 将不同索引处的值替换
* shuffle 进行随机的排序
* max 默认是自然顺序找最大的 你也可以传入比较器
* min 同理
* frequency 在指定的集合里查找某个特定的元素出现的次数
* copy(dest,src )  将src 中的赋给 dest  ps: 但是要注意了 这里的dest 的长度要大于等于src的否则直接给你报错
* replace (list,oldVal,newVal),用新值来替换旧的值

