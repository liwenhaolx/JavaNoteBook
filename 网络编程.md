# 网络编程

1. IP 地址是一个主机唯一的标识,相当于你的身份证号
2. 端口:端口就是标识一个网络程序的,即一个端口对应的一个网络程序
3. 域名:域名可以映射为一个IP地址,方便记忆
4. 协议:就是数据的组织形式,好像就是我们的语言,我们的语言就是一种协议
5. 网络的传输是这样的 : 用户数据 进行打包变成 应用数据 再变成 tcp的某种数据 在变成 某种IP协议的数据 ,然后变成以太网数据帧,再能在物理的网络中传输

## TCP and UDP

* TCP : 这个协议在传输数据时 是先建立一个数据的通道,并且进行了三次握手的 再传输数据 因此他是适合传输数据量大的可靠的 但是在每一次传完数据后 要断开链接  就像打电话一样 ,你不挂电话 别人打电话了,你不一定接收的到,他一般会提示对方正在通话中,让你不要挂机
* UDP: 就是没有建立连接的通道而是直接发数据 不管你接收到没有,因此他是不可靠的 就像你发短信的时候,你发出去了就不管了,你不管收信人收到没有

## InetAdress

```java
import java.net.InetAddress;
import java.net.UnknownHostException;

public class API_ {
    public static void main(String[] args) throws UnknownHostException {
        //获取本机的主机名 和 IP地址
        InetAddress localHost = InetAddress.getLocalHost();
        System.out.println(localHost);
        //根据指定的主机名 / 域名 来获取ip地址
        InetAddress host1 = InetAddress.getByName("LAPTOP-U3OCPGVJ");
        InetAddress byName = InetAddress.getByName("www.baidu.com");
        System.out.println(host1);
        System.out.println(byName);
        //通过InetAddress 对象来获取 主机名 或 域名
        //以及ip地址
        String hostAddress = localHost.getHostAddress();
        String hostName = localHost.getHostName();
        System.out.println(hostAddress + " " + hostName);

    }
}

```

## socket

1. Socket 能够让网络数据间的传输 变成一种IO流的方式来
2. 发出请求的一方是客户端,监听接收请求的一方是服务端
3. 用完后记得断开连接 否则 会导致 服务端的连接一直变成很多让其他的客户端无法连接



* 这个是客户端

```java
package TCP_;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;

//客户端
public class Client01 {
    public static void main(String[] args) throws IOException {
        //连接端口(因为我的服务器就在我本机,所以这里就是写的我自己的主机名,如果你的服务器他其他地方,你可以写他的IP地址)
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);

        //客户端输出
        OutputStream outputStream = socket.getOutputStream();
        outputStream.write("hello,java!".getBytes());

        System.out.println("客户端 " + " " + socket.getClass());
        //客户端关闭
        outputStream.close();
        socket.close();
        System.out.println("客户端关闭了");
    }
}

```







* 这个是服务端

```java
package TCP_;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

//服务器端
public class Server01 {
    public static void main(String[] args) throws IOException {
        System.out.println("服务器正在监听9999端口");
        //监听端口9999
        ServerSocket serverSocket = new ServerSocket(9999);

        //等待连接
        System.out.println("等待连接");
        Socket socket = serverSocket.accept();

        // 客户端接收数据
        InputStream inputStream = socket.getInputStream();
        byte[] buf = new byte[1024];
        int len = 0;
        if (inputStream != null) {
            while ((len = inputStream.read(buf)) != -1) {
                System.out.println(new String(buf, 0, len));
            }
        }
        System.out.println("服务端socekt = " + socket.getClass());


        //服务端关闭
        serverSocket.close();
        socket.close();
        if (inputStream != null) {
            inputStream.close();
        }
    }
}

```

# TCP编程理念

1. TCP编程 其实就是一种数据的传输 数据的传输,就会用到IO流的知识
2. TCP编程里面重要的知识就是可以通过socket来获取关联了socket的输入和输出流
3. 对于服务端而言是要去监听端口的 当客户端来连接这个端口时就把建立了一个数据的通道 并把一个随机的端口给了客户端

看图

![image-20211224181739074](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211224181739074.png)

对于上传一个文件就是先将这个文件从本地磁盘拿到程序里 在有程序把这个文件放到服务端 这是上传文件的底层逻辑

# serversocket

1. 这个就是用来监听的,调用他的方法 accept(),程序会停在这里等待客户端来连接这个端口然后再来执行一些任务
2. 当连接后这个方法会返回一个socket的对象 用这个对象可以获取到与这个想关联的socket的输入输出流 
3. 但是当一个服务端的数据通道多了会不许其他的客户端来连接 所以用完之后一定要关闭socket 还要就是流对象也一定要关闭
4. 只要是一种资源,就要把他关闭了

```java
package TCP_;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
@SuppressWarnings({"all"})
//三号服务端
public class Server03 {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(9997);
        System.out.println("三号服务端在监听9997号端口");
        Socket socket = serverSocket.accept();

        InputStream it = socket.getInputStream();
        //使用字符流来接收数据

        System.out.println("三号服务端接收的数据:");
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(it));
        String s = bufferedReader.readLine();
        System.out.println(s);


        //回发消息
        System.out.println("三号服务端在回发消息(字符的方式)");
        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
        bufferedWriter.write("java,yyds");
        bufferedWriter.newLine();
        bufferedWriter.flush();

        //关闭资源
        it.close();
        socket.close();
        serverSocket.close();
        bufferedWriter.close();
        bufferedReader.close();
        System.out.println("三号服务端关闭!");

    }
}

```





```java
package TCP_;

import java.io.*;
import java.net.InetAddress;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
@SuppressWarnings({"all"})
//三号客户端
public class Client03 {
    public static void main(String[] args) throws IOException {
        //连接9998端口
        System.out.println("三号客户端正在连接9997端口.......");
        Socket socket = new Socket(InetAddress.getLocalHost(), 9997);

        OutputStream ot = socket.getOutputStream();
        System.out.println("三号客户端正在写入数据......");
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(ot));
        bufferedWriter.write("你好,java 你好,IOTU");
        bufferedWriter.newLine();//这个就相当于结束的标志这里意味着对方要用readline来读取
        bufferedWriter.flush();//用这个刷新才能让你要写的内容写进去


        //三号客户端在读入三号服务端来的数据
        System.out.println("三号客户端读取中...");
        InputStream it = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(it));
        String s = bufferedReader.readLine();
        System.out.println(s);

        //关闭资源
        socket.close();
        ot.close();
        it.close();
        System.out.println("二号客户端结束运行");

    }
}

```

![image-20211229144220448](C:\Users\故事与酒\AppData\Roaming\Typora\typora-user-images\image-20211229144220448.png)

