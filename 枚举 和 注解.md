# 枚举 和 注解

## 来看看枚举的定义

枚举就是一个一个的数出来, 即是有限的对象实例且是固定的

枚举也是一种特殊的类

枚举类有两种实现的方式

1. 自定义枚举类
2. 使用关键字enum

```java
public class EnumText01 {
    public static void main(String[] args) {
        System.out.println(Book.BOOK1);
        System.out.println(Book.BOOK2);
        System.out.println(Book.BOOK3);
        
    }
}


//自定义枚举类
class Book{
    private String name;
    private int price;
    //内部创建对象(静态的引用指向他)
    public static final Book BOOK1 = new Book("战争与和平",100);
    public static final Book BOOK2 = new Book("猫和老鼠",80);
    public static final Book BOOK3 = new Book("阿衰",10);

    private Book(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return "名字: "+ name+" "+ "价格: "+ price;
    }
}
```

```java
public class EnumTextv2 {
    public static void main(String[] args) {
        System.out.println(Book1.BOOK1+"\n"+Book1.BOOK2+"\n"+Book1.BOOK3+"\n");
    }
}


//使用关键字
enum Book1{
    BOOK1("论语",80),BOOK2("道德经",800),BOOK3("金刚经",1000);

    private String name;
    private int price;

    Book1(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return "名字: "+ name+" "+ "价格: "+ price;
    }
    
}

```

1. 使用关键字来定义的枚举类是有些不同

* 首先是在内部创建对象的时候 并没有用new() 而是直接用对象名加参数列表
* 其二 所有用了enum关键字的都是默认继承Enum 的在Enum 中是重写了ToString 方法的 返回的是你的对象名
* 你的对象必须在第一行
* 使用无参构造器的时候可以直接没有参数列表和小括号

### 枚举类常用的方法

1. toString 方法 (在前面已经提到过他被重写了)
2. name 返回常量名(即你的对象名)
3. ordinal 返回当前对象的序列号
4. values 返回当前枚举类的所有常量
5. valueOf 将字符串转换为枚举对象 要求 字符串必须是已经有了的常量名 否则报错
6. compareTo 比较两个枚举常量  比较的是编号 编号从零开始

```java
public class EnumTextv2 {
    public static void main(String[] args) {
//        System.out.println(Book1.BOOK1+"\n"+Book1.BOOK2+"\n"+Book1.BOOK3+"\n");
        //直接来演示方法
        /*
        *   1. toString 方法 (在前面已经提到过他被重写了)
            2. name 返回常量名(即你的对象名)
            3. ordinal 返回当前对象的序列号
            4. values 返回当前枚举类的所有常量
            5. valueOf 将字符串转换为枚举对象 要求 字符串必须是已经有了的常量名 否则报错
            6. compareTo 比较两个枚举常量  比较的是编号 编号从零开始*/
        Book1 book1 = Book1.BOOK1;
        System.out.println(book1.name());
        System.out.println(book1.ordinal());
        System.out.println(Book1.values());
        System.out.println(Book1.valueOf("BOOK2"));
        System.out.println(book1.compareTo(Book1.BOOK3));
        Book1[] book1s = Book1.values();
        for (Book1 book11 :book1s) {
            System.out.println(book11);
        }

    }
}


//使用关键字
enum Book1{
    BOOK1("论语",80),BOOK2("道德经",800),BOOK3("金刚经",1000);

    private String name;
    private int price;

    Book1(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return "名字: "+ name+" "+ "价格: "+ price;
    }

}

```



1. 值得注意的是这里的values() 返回的是该对象的数组
2. 因为使用的关键字enum 自动的继承了Enum 的类不能在继承其他的类 所以要想扩展就只能来实现接口了

## 这里简单的介绍一下注解

常见的注解有三种

1. @Overrride  是来限定某个方法一定必须是重写了父类的的方法 否则就会报错
2. @Deprecated 是用来表示某个东西过时了
3. @SuppressWarnings   是来抑制编译器的警告的

### 一些元注解 (就是解释注解的注解)

1. Retention  指定注解的作用范围 (SOURCE CLASS RUNTIME)
2. Target 指定注解在那些地方可以使用
3. Documented 指定该注解是否会在Javadoc中体现
4. Inheriter 子类会继承父类的注解

